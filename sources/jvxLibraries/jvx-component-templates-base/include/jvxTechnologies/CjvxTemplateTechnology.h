#ifndef __CJVXTEMPLATETECHNOLOGY_H__
#define __CJVXTEMPLATETECHNOLOGY_H__

#include "jvx.h"

#include "common/CjvxProperties.h"
#include "common/CjvxTechnology.h"

/**
 * This template class can be configured for the following use-cases:
 * 
 * 1) Expose all HW components in the system (typical: audio HW devices)
 * 2) Expose a variable number of devices: Devices can be added and removed while
 *    in operation
 * 3) Expose only one device but multiple instances can be used by activating the same 
 *    device multiple times
 * 
 * The functionality for 1) is realized in the base class CjvxTechnologyDevCaps/CjvxTechnology.
 * 
 * The extensions for 2) are handled externally in the class which uses this class by derivation.
 * A example is the class CjvxSignalProcessingTechnologySocket which is used in the project
 * jvxUnrealRender which connects jvxrt to the unreal engine. Note that the extension to 
 * allow a variable number of devices is handled by the modified API to deal with device pointer
 * instances rather that simple ids in request_device and return_device.
 * 
 * For 3), the member variable allowMultipleInstances must be true. In that case on "request_device",
 * always a new device will be allocated and stored in the field lookupDevice. Also, a reference counter will
 * keep track of all requested and returned devices.
 * 
 * All requests to member functions must be thread safe - all from within main thread OR within a global lock.
 * 
 */
template <class T> class CjvxTemplateTechnology: 
	public IjvxTechnology, public CjvxTechnology,
	public IjvxProperties, public CjvxProperties
{
protected:

	class oneRequestedDevice
	{
	public:

		// This is a pointer to the new device as generated by activation of a proxy
		T* new_dev = nullptr;

		// This is the parent device which is actually the proxy
		IjvxDevice* parent = nullptr;
	};

	/** 
	 * Keep track of the requested devices in case one exposed device 
	 * grants access to an infinite number of instances. 
	 * Note that all devices must be returned on program termination.
	 */
	std::map<IjvxDevice*,oneRequestedDevice> lookupDevice;
	
	//! Use this variable to generate devices with token <deviceNamePrefix> # i
	std::string deviceNamePrefix = "Single Device";

	//! Number of devices to be allocated on init by default
	jvxSize numberDevicesInit = 1;

	//! Unique id counter to 
	jvxSize uId = 1;

	/**
	 * Enable to allow exposure of multiple devices when requesting a single device.
	 * This must be false in all cases other than 2). 
	 */
	jvxBool actAsProxy_init = false;

	std::list<IjvxDevice*> proxyDevices_configure;

public:

	// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
	// Component class interface member functions
	// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
	JVX_CALLINGCONVENTION CjvxTemplateTechnology(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_DECLARE):
		CjvxTechnology(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_CALL), CjvxProperties(module_name, *this)
	{
		JVX_OBJECT_ASSIGN_INTERFACE_FACTORY(this);
		_common_set.theComponentType.tp = tpComp;
		_common_set.theObjectSpecialization = reinterpret_cast<jvxHandle*>(static_cast<IjvxTechnology*>(this));
		_common_set.thisisme = static_cast<IjvxObject*>(this);
		_common_set.theInterfaceFactory = static_cast<IjvxInterfaceFactory*>(this);
		
		/*
		deviceNamePrefix = "Single Device";
		numberDevicesInit = 1;
		uId = 1;
		allowMultipleInstances = true;
		*/
	};

	virtual JVX_CALLINGCONVENTION ~CjvxTemplateTechnology()
	{
		terminate();
	};
	
	// ======================================================

	virtual jvxErrorType JVX_CALLINGCONVENTION activate()override
	{
		jvxSize i;
		jvxErrorType res = res = _activate();
		if(res == JVX_NO_ERROR)
		{
			// Allocate the default number of devices on init
			for (i = 0; i < numberDevicesInit; i++)
			{
				// Do whatever is required
				T* newDevice = local_allocate_device(deviceNamePrefix.c_str(), false,
					_common_set.theDescriptor.c_str(),
					_common_set.theFeatureClass,
					_common_set.theModuleName.c_str(),
					JVX_COMPONENT_ACCESS_SUB_COMPONENT,
					(jvxComponentType)(_common_set.theComponentType.tp + 1),
					"", NULL, JVX_SIZE_UNSELECTED, actAsProxy_init, NULL);
				if (newDevice == nullptr)
				{
					newDevice = new T(deviceNamePrefix.c_str(), false,
						_common_set.theDescriptor.c_str(),
						_common_set.theFeatureClass,
						_common_set.theModuleName.c_str(),
						JVX_COMPONENT_ACCESS_SUB_COMPONENT,
						(jvxComponentType)(_common_set.theComponentType.tp + 1),
						"", NULL);
				}								

				// Whatever to be done for initialization
				oneDeviceWrapper elm;
				elm.hdlDev = static_cast<IjvxDevice*>(newDevice);
				elm.actsAsProxy = actAsProxy_init;
				_common_tech_set.lstDevices.push_back(elm);
			}
		}
		return(res);
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION deactivate()override
	{
		jvxErrorType res = _pre_check_deactivate();
		if (res == JVX_NO_ERROR)
		{
			for (auto& elmP : proxyDevices_configure)
			{
				return_device(elmP);
			}
			proxyDevices_configure.clear();

			auto elm = _common_tech_set.lstDevices.begin();
			for (; elm != _common_tech_set.lstDevices.end(); elm++)
			{
				assert(elm->refCnt == 0);
				// if (local_deallocate_device(elm->hdlDev, false) != JVX_NO_ERROR) <- we have not type specific reference here,
				// therefore, we are able to use the default deallocation only
				delete elm->hdlDev;
			}
			_common_tech_set.lstDevices.clear();
			assert(lookupDevice.size() == 0);

			res = _deactivate();
		}
		return res;
	}

	// ======================================================

	virtual jvxErrorType JVX_CALLINGCONVENTION request_device(jvxSize idx, IjvxDevice** dev, jvxCBitField requestFlags)override
	{
		jvxErrorType res = JVX_NO_ERROR;		

		if (idx < _common_tech_set.lstDevices.size())
		{
			auto elm = _common_tech_set.lstDevices.begin();
			std::advance(elm, idx);

			// If multiple devices are allowed, one exposed device will allow to create an infinite number of devices
			if (elm->actsAsProxy && !jvx_bitTest(requestFlags, jvxRequestDeviceOptions::JVX_REQUEST_REFERENCE_PROXY_SHIFT))
			{
				oneRequestedDevice newElm;
				newElm.parent = elm->hdlDev;
				elm->refCnt++;

				std::string deviceName = deviceNamePrefix + "_" + jvx_size2String(elm->nSubElements);
				elm->nSubElements++;

				T* newDevice = local_allocate_device(deviceName.c_str(), false, _common_set.theDescriptor.c_str(), _common_set.theFeatureClass,
					_common_set.theModuleName.c_str(), JVX_COMPONENT_ACCESS_SUB_COMPONENT,
					(jvxComponentType)(_common_set.theComponentType.tp + 1), "", NULL, idx, false, nullptr);

				if (newDevice == nullptr)
				{
					JVX_SAFE_ALLOCATE_OBJECT(newDevice, T(deviceName.c_str(), false, _common_set.theDescriptor.c_str(), _common_set.theFeatureClass,
						_common_set.theModuleName.c_str(), JVX_COMPONENT_ACCESS_SUB_COMPONENT,
						(jvxComponentType)(_common_set.theComponentType.tp + 1), "", NULL));
				}

				// Store in list for requested devices
				newElm.new_dev = newDevice;
				IjvxDevice* ptrRegister = static_cast<IjvxDevice*>(newElm.new_dev);
				lookupDevice[ptrRegister] = newElm;
				uId++;

				// Assign device
				if (dev)
				{
					*dev = ptrRegister;
				}
			}
			else
			{
				if (elm->refCnt == 0)
				{
					elm->refCnt++;
					if (dev)
					{
						*dev = elm->hdlDev;
					}
				}
				else
				{
					res = JVX_ERROR_ALREADY_IN_USE;
				}
			}
		}
		else
		{
			// We end up here if the proxy sub device was allocated on configure and will be taken over by activation in the host
			idx -= _common_tech_set.lstDevices.size();
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx);
				auto elmL = proxyDevices_configure.begin();

				// Remove this from the list of devices on configure
				for (; elmL != proxyDevices_configure.end(); elmL++)
				{
					if (*elmL == elm->second.new_dev)
					{
						proxyDevices_configure.erase(elmL);
						break;
					}
				}

				*dev = elm->second.new_dev;
			}
			else
			{
				res = JVX_ERROR_ID_OUT_OF_BOUNDS;
			}
		}

		return res;
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION proxy_device_on_configure(jvxSize idx)
	{
		IjvxDevice* dev = nullptr;
		jvxCBitField requestFlags = 0;
		jvxErrorType res = request_device(idx, &dev, requestFlags);
		if (res == JVX_NO_ERROR)
		{
			// We need to store the device here to hold a reference in case we need to remove it on deactivate
			proxyDevices_configure.push_back(dev);
		}
		return res;
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION return_device(IjvxDevice* dev)override
	{
		jvxErrorType res = JVX_NO_ERROR;
		jvxBool foundLookup = false;
		IjvxDevice* parentRef = NULL;

		// Check if device is in lookup list
		auto elm = lookupDevice.find(dev);
		if (elm != lookupDevice.end())
		{
			parentRef = static_cast<IjvxDevice*>(elm->second.parent);
			foundLookup = true;
			local_deallocate_device(&elm->second.new_dev, nullptr);
			if (elm->second.new_dev)
			{
				JVX_SAFE_DELETE_OBJECT(elm->second.new_dev);
			}

			// Decrement counter for sub elements in parent to show the same numbers for every new device
			for (auto& elmP : _common_tech_set.lstDevices)
			{
				if (elmP.hdlDev == elm->second.parent)
				{
					elmP.nSubElements--;
				}
			}
			lookupDevice.erase(elm);		
		}

		// If not, continue checking actual list
		if (!foundLookup)
		{
			parentRef = dev;
		}
		
		// Check all list elements
		auto elmD = _common_tech_set.lstDevices.begin();
		for (; elmD != _common_tech_set.lstDevices.end(); elmD++)
		{
			if (parentRef == static_cast<IjvxDevice*>(elmD->hdlDev))
			{
				assert(elmD->refCnt > 0);
				elmD->refCnt--;
				break;
			}
		}

		if (elmD == _common_tech_set.lstDevices.end())
		{
			res = JVX_ERROR_ELEMENT_NOT_FOUND;
		}
		return res;
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION ident_device(jvxSize* idx, IjvxDevice* dev)override
	{
		jvxErrorType res = JVX_NO_ERROR;
		jvxSize id = JVX_SIZE_UNSELECTED;
		jvxSize cnt = 0;
		jvxBool foundLookup = false;

		auto elmD = _common_tech_set.lstDevices.begin();
		for (; elmD != _common_tech_set.lstDevices.end(); elmD++, cnt++)
		{
			if (dev == static_cast<IjvxDevice*>(elmD->hdlDev))
			{				
				break;
			}
		}

		if (elmD != _common_tech_set.lstDevices.end())
		{
			id = cnt;
		}
		else
		{
			// Check lookup second			
			auto elm = lookupDevice.begin();
			for (; elm != lookupDevice.end(); elm++, cnt++)
			{
				if (dev == static_cast<IjvxDevice*>(elm->second.new_dev))
				{
					break;
				}
			}
			
			if (elm == lookupDevice.end())
			{
				res = JVX_ERROR_ELEMENT_NOT_FOUND;
			}
			else
			{
				id = cnt;
			}
		}

		if (idx)
		{
			*idx = id;
		}

		return res;
	};	

	jvxErrorType _put_configuration_active(jvxCallManagerConfiguration* callConf,
		IjvxConfigProcessor* processor,
		jvxHandle* sectionToContainAllSubsectionsForMe, const char* filename,
		jvxInt32 lineno)
	{
		jvxConfigData* datProxies = nullptr;
		jvxSize cnt = 0;
		jvxSize i;
		processor->getReferenceEntryCurrentSection_name(sectionToContainAllSubsectionsForMe, &datProxies, "JVX_PROXY_INSTANCES");
		if (datProxies)
		{
			jvxSize cnt = 0;
			while (1)
			{
				jvxConfigData* datOneProxy = nullptr;
				std::string token = "JVX_PROXY_" + jvx_size2String(cnt);
				cnt++;
				processor->getReferenceEntryCurrentSection_name(datProxies, &datOneProxy, token.c_str());
				if (datOneProxy == nullptr)
				{
					break;
				}
				else
				{
					jvxConfigData* datProxyName = nullptr;
					processor->getReferenceEntryCurrentSection_name(datOneProxy, &datProxyName, "JVX_PROXY_NAME");

					jvxConfigData* datNumProxies = nullptr;
					processor->getReferenceEntryCurrentSection_name(datOneProxy, &datNumProxies, "JVX_NUM_PROXY_DEVICES");

					if (datProxyName && datNumProxies)
					{
						jvxApiString astr;
						jvxSize num = 0;
						jvxValue numV;
						processor->getAssignmentString(datProxyName, &astr);
						processor->getAssignmentValue(datNumProxies, &numV);
						std::string pName = astr.std_str();
						numV.toContent(&num);
						jvxSize devCnt = 0;
						for (auto& elm : _common_tech_set.lstDevices)
						{
							elm.hdlDev->name(&astr, nullptr);
							if (astr.std_str() == pName)
							{
								jvxSize cntAlreadyThere = 0;
								for (auto elmThere : lookupDevice)
								{
									if (elmThere.second.parent == elm.hdlDev)
									{
										cntAlreadyThere++;
									}
								}
								for (i = cntAlreadyThere; i < num; i++)
								{
									proxy_device_on_configure(devCnt);
								}
								break;
							}
							devCnt++;
						}
					}

				}
			}
		}
		return JVX_NO_ERROR;
	};

	jvxErrorType _get_configuration_active(jvxCallManagerConfiguration* callConf, IjvxConfigProcessor* processor,
		jvxHandle* sectionWhereToAddAllSubsections)
	{
		jvxConfigData* datProxies = nullptr;
		jvxSize cnt = 0;
		processor->createEmptySection(&datProxies, "JVX_PROXY_INSTANCES");
		for (auto elm : _common_tech_set.lstDevices)
		{
			if (elm.actsAsProxy)
			{
				jvxApiString astr;
				IjvxDevice* dev = elm.hdlDev;
				jvxConfigData* datOneProxy = nullptr;
				jvxConfigData* datProxySubElements = nullptr;
				std::string token = "JVX_PROXY_" + jvx_size2String(cnt);
				processor->createEmptySection(&datOneProxy, token.c_str());
				processor->createAssignmentStringList(&datProxySubElements, "JVX_PROXY_SUB_DEVICES");

				jvxSize cntDevices = 0;
				for (auto elmP : lookupDevice)
				{
					if (elmP.second.parent == dev)
					{
						cntDevices++;
						elmP.second.new_dev->name(&astr, nullptr);
						processor->addAssignmentStringToList(datProxySubElements, astr.c_str());
					}
				}
				jvxConfigData* datNumProxies = nullptr;
				processor->createAssignmentValue(&datNumProxies, "JVX_NUM_PROXY_DEVICES", cntDevices);
				processor->addSubsectionToSection(datOneProxy, datNumProxies);
				processor->addSubsectionToSection(datOneProxy, datProxySubElements);

				jvxConfigData* datProxyName = nullptr;
				elm.hdlDev->name(&astr, nullptr);
				processor->createAssignmentString(&datProxyName, "JVX_PROXY_NAME", astr.c_str());
				processor->addSubsectionToSection(datOneProxy, datProxyName);

				processor->addSubsectionToSection(datProxies, datOneProxy);
			}
		}
		processor->addSubsectionToSection(sectionWhereToAddAllSubsections, datProxies);
		return JVX_NO_ERROR;
	};

	virtual T* local_allocate_device(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_DECLARE, 
		jvxSize idx /* = JVX_SIZE_UNSELECTED*/, 
		jvxBool actAsProxy_init /*= false*/,
		jvxHandle* fwd_arg /*= nullptr*/)
	{
		// No specific allocation function as the default
		return nullptr;
	}

	// This function is always called for a proxy device as it requires a specific device pointer handle
	// Otherwise, the default deallocation is used
	virtual jvxErrorType local_deallocate_device(T** elmDev, jvxHandle* fwd_args)
	{
		return JVX_ERROR_NOT_IMPLEMENTED;
	}

	// ===========================================================================================

	jvxErrorType number_devices(jvxSize* num) override
	{
		jvxSize numPartStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numPartStat);
		jvxSize numPartDyn = lookupDevice.size();
		if (num) *num = numPartStat + numPartDyn;
		return res;
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION name_device(jvxSize idx, jvxApiString* name, jvxApiString* fName) override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx );
				return elm->second.new_dev->name(name, fName);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_name_device(idx, name, fName));
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION description_device(jvxSize idx, jvxApiString* str) override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx);
				return elm->second.new_dev->description(str);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_description_device(idx, str));
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION descriptor_device(jvxSize idx, jvxApiString* str, jvxApiString* substr)override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx);
				return elm->second.new_dev->descriptor(str, substr);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_descriptor_device(idx, str, substr));
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION module_name_device(jvxSize idx, jvxApiString* str) override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx );
				return elm->second.new_dev->module_reference(str, nullptr);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_module_name_device(idx, str));
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION capabilities_device(jvxSize idx, jvxDeviceCapabilities& caps) override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx);
				return elm->second.new_dev->capabilities_device(caps);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_capabilities_device(idx, caps));
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION location_info_device(jvxSize idx, jvxComponentIdentification& tpId) override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx );
				return elm->second.new_dev->location_info(tpId);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_location_info_device(idx, tpId));
	};

	virtual jvxErrorType JVX_CALLINGCONVENTION status_device(jvxSize idx, jvxState* stat) override
	{
		jvxSize numStat = 0;
		jvxErrorType res = CjvxTechnology::_number_devices(&numStat);
		if (idx >= numStat)
		{
			idx -= numStat;
			if (idx < lookupDevice.size())
			{
				auto elm = lookupDevice.begin();
				std::advance(elm, idx );
				return elm->second.new_dev->state(stat);
			}
			return JVX_ERROR_ID_OUT_OF_BOUNDS;
		}
		return(CjvxTechnology::_status_device(idx, stat));
	};

	// ================================================================================================
#include "codeFragments/simplify/jvxProperties_simplify.h"

#define JVX_STATE_MACHINE_DEFINE_PREPAREPOSTPROCESS_UNSUPPORTED
#define JVX_STATE_MACHINE_DEFINE_STARTSTOP_UNSUPPORTED
#define	JVX_STATE_MACHINE_DEFINE_READY_UNSUPPORTED
	#include "codeFragments/simplify/jvxStateMachine_simplify.h"
#undef JVX_STATE_MACHINE_DEFINE_READY_UNSUPPORTED
#undef JVX_STATE_MACHINE_DEFINE_STARTSTOP_UNSUPPORTED
#undef JVX_STATE_MACHINE_DEFINE_PREPAREPOSTPROCESS_UNSUPPORTED

	#include "codeFragments/simplify/jvxObjects_simplify.h"

#define JVX_INTERFACE_SUPPORT_PROPERTIES
#include "codeFragments/simplify/jvxHiddenInterface_simplify.h"
#undef JVX_INTERFACE_SUPPORT_PROPERTIES

#include "codeFragments/simplify/jvxInterfaceReference_simplify.h"
#include "codeFragments/simplify/jvxSystemStatus_simplify.h"

	// ===========================================================================================
	// ===========================================================================================
};

#ifdef JVX_AUDIO_TECHNOLOGY_GENERIC_INIT_PTR 
JVX_AUDIO_TECHNOLOGY_GENERIC_INIT_PTR parentPointerDevice = nullptr;
#endif

template <class T, class S> class CjvxTemplateTechnologyInit : public CjvxTemplateTechnology<T>
{
protected:
	S passThisInit = nullptr;

public:

	JVX_CALLINGCONVENTION CjvxTemplateTechnologyInit(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_DECLARE) :
		CjvxTemplateTechnology<T>(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_CALL)
	{};

	T* local_allocate_device(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_DECLARE, jvxSize idx, jvxBool actAsProxy_init)
	{
		T* newDev = nullptr;
		JVX_SAFE_ALLOCATE_OBJECT(newDev, T(JVX_CONSTRUCTOR_ARGUMENTS_MACRO_CALL));
		newDev->init(passThisInit);
		return newDev;
	}

	jvxErrorType local_deallocate_device(T** elmDev, jvxHandle* fwd_args)
	{
		assert(0);
		return JVX_ERROR_NOT_IMPLEMENTED;
	}

	/*
	virtual void local_init(T* newDevice) override
	{
		newDevice->init(passThisInit);
	};
	*/
};

#endif
